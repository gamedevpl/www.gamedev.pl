/**
 * Utilities for exporting scenarios as JSON or TypeScript code.
 */

import { ScenarioConfig } from './scenario-types';

/**
 * Exports the scenario configuration as a formatted JSON string.
 */
export function exportScenarioAsJson(config: ScenarioConfig): string {
  return JSON.stringify(config, null, 2);
}

/**
 * Exports the scenario configuration as TypeScript code that can be
 * pasted into the game's source code.
 */
export function exportScenarioAsTypeScript(config: ScenarioConfig): string {
  const lines: string[] = [];

  lines.push(`/**`);
  lines.push(` * Scenario: ${config.name}`);
  if (config.description) {
    lines.push(` * ${config.description}`);
  }
  lines.push(` * Generated by Scenario Editor`);
  lines.push(` */`);
  lines.push(``);
  lines.push(`import { createEntities, createBerryBush, createHuman, createPrey, createPredator, createBuilding } from './entities/entities-update';`);
  lines.push(`import { GameWorldState } from './world-types';`);
  lines.push(`import { MAP_WIDTH, MAP_HEIGHT } from './game-consts';`);
  lines.push(`import { generateRandomPreyGeneCode } from './entities/characters/prey/prey-utils';`);
  lines.push(`import { generateRandomPredatorGeneCode } from './entities/characters/predator/predator-utils';`);
  lines.push(`import { BuildingType } from './entities/buildings/building-types';`);
  lines.push(``);
  lines.push(`export function initScenario_${sanitizeName(config.name)}(): GameWorldState {`);
  lines.push(`  const entities = createEntities();`);
  lines.push(`  const initialTime = 0;`);
  lines.push(``);

  // Generate berry bushes
  if (config.berryBushes.length > 0) {
    lines.push(`  // Create berry bushes`);
    for (const bush of config.berryBushes) {
      lines.push(`  createBerryBush(entities, { x: ${bush.position.x}, y: ${bush.position.y} }, initialTime);`);
    }
    lines.push(``);
  }

  // Generate tribes and humans
  if (config.tribes.length > 0) {
    lines.push(`  // Create tribes and humans`);

    // First pass: create leaders
    for (const tribe of config.tribes) {
      const leader = tribe.humans.find((h) => h.isLeader);
      if (leader) {
        const varName = `tribe_${sanitizeName(tribe.id)}_leader`;
        lines.push(`  const ${varName} = createHuman(`);
        lines.push(`    entities,`);
        lines.push(`    { x: ${leader.position.x}, y: ${leader.position.y} },`);
        lines.push(`    initialTime,`);
        lines.push(`    '${leader.gender}',`);
        lines.push(`    ${leader.isPlayer ? 'true' : 'false'},`);
        lines.push(`    ${leader.age},`);
        lines.push(`  );`);
        lines.push(`  ${varName}.leaderId = ${varName}.id;`);
        lines.push(`  ${varName}.tribeBadge = '${tribe.badge}';`);
        lines.push(``);
      }
    }

    // Second pass: create other tribe members
    for (const tribe of config.tribes) {
      const leaderVarName = `tribe_${sanitizeName(tribe.id)}_leader`;
      const members = tribe.humans.filter((h) => !h.isLeader);
      for (const member of members) {
        const varName = `human_${sanitizeName(member.id)}`;
        lines.push(`  const ${varName} = createHuman(`);
        lines.push(`    entities,`);
        lines.push(`    { x: ${member.position.x}, y: ${member.position.y} },`);
        lines.push(`    initialTime,`);
        lines.push(`    '${member.gender}',`);
        lines.push(`    ${member.isPlayer ? 'true' : 'false'},`);
        lines.push(`    ${member.age},`);
        lines.push(`  );`);
        lines.push(`  ${varName}.leaderId = ${leaderVarName}.id;`);
        lines.push(`  ${varName}.tribeBadge = '${tribe.badge}';`);
        lines.push(``);
      }
    }
  }

  // Generate prey
  if (config.prey.length > 0) {
    lines.push(`  // Create prey`);
    for (const prey of config.prey) {
      lines.push(`  createPrey(entities, { x: ${prey.position.x}, y: ${prey.position.y} }, '${prey.gender}', undefined, undefined, generateRandomPreyGeneCode());`);
    }
    lines.push(``);
  }

  // Generate predators
  if (config.predators.length > 0) {
    lines.push(`  // Create predators`);
    for (const predator of config.predators) {
      lines.push(`  createPredator(entities, { x: ${predator.position.x}, y: ${predator.position.y} }, '${predator.gender}', undefined, undefined, generateRandomPredatorGeneCode());`);
    }
    lines.push(``);
  }

  // Generate buildings
  if (config.buildings.length > 0) {
    lines.push(`  // Create buildings`);
    for (const building of config.buildings) {
      const ownerVarName = `tribe_${sanitizeName(building.tribeId)}_leader`;
      lines.push(`  const building_${sanitizeName(building.id)} = createBuilding(`);
      lines.push(`    entities,`);
      lines.push(`    { x: ${building.position.x}, y: ${building.position.y} },`);
      lines.push(`    BuildingType.${capitalizeFirst(building.type)},`);
      lines.push(`    ${ownerVarName}.id,`);
      lines.push(`  );`);
      if (building.isConstructed) {
        lines.push(`  building_${sanitizeName(building.id)}.isConstructed = true;`);
        lines.push(`  building_${sanitizeName(building.id)}.constructionProgress = 1;`);
      }
      lines.push(``);
    }
  }

  // Find the player entity (for potential future use in generated code)
  const playerTribe = config.tribes.find((t) => t.id === config.playerTribeId);
  const playerHuman = playerTribe?.humans.find((h) => h.isPlayer);
  // Player variable name can be used in generated code for viewport centering
  const _playerVarName = playerHuman?.isLeader
    ? `tribe_${sanitizeName(config.playerTribeId || '')}_leader`
    : `human_${sanitizeName(playerHuman?.id || '')}`;
  void _playerVarName; // Mark as intentionally unused for now

  lines.push(`  // Return the initial world state (simplified - add remaining fields as needed)`);
  lines.push(`  return {`);
  lines.push(`    time: initialTime,`);
  lines.push(`    entities,`);
  lines.push(`    mapDimensions: { width: ${config.mapWidth}, height: ${config.mapHeight} },`);
  if (config.playerStartPosition) {
    lines.push(`    viewportCenter: { x: ${config.playerStartPosition.x}, y: ${config.playerStartPosition.y} },`);
  } else {
    lines.push(`    viewportCenter: { x: ${config.mapWidth / 2}, y: ${config.mapHeight / 2} },`);
  }
  lines.push(`    // ... add other required GameWorldState fields`);
  lines.push(`  } as unknown as GameWorldState;`);
  lines.push(`}`);

  return lines.join('\n');
}

/**
 * Sanitizes a name to be used as a variable name.
 */
function sanitizeName(name: string): string {
  return name
    .replace(/[^a-zA-Z0-9]/g, '_')
    .replace(/^_+|_+$/g, '')
    .replace(/_+/g, '_')
    .toLowerCase();
}

/**
 * Capitalizes the first letter of a string.
 */
function capitalizeFirst(str: string): string {
  return str.charAt(0).toUpperCase() + str.slice(1);
}

/**
 * Copies text to the clipboard.
 */
export async function copyToClipboard(text: string): Promise<boolean> {
  try {
    await navigator.clipboard.writeText(text);
    return true;
  } catch (err) {
    console.error('Failed to copy to clipboard:', err);
    return false;
  }
}
